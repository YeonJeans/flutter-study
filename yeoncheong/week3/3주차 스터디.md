# 3주차 스터디

# Navigation and routing

## Using the Navigator

Navigator 위젯은 화면을 스택으로 표시

새 화면으로 이동할 경우 경로의 `BuildContext`를 통해 Navigator에 액세스하고 `push()` 또는 `pop()`과 같은 필수 메서드를 호출

```dart
onPressed: () {
  Navigator.of(context).**push**(
    **MaterialPageRoute**(
      builder: (context) => const SongScreen(song: song),
    ),
  );
},
child: Text(song.name),
```

- Navigator는 Route 객체의 스택(내역 스택)을 유지하기 때문에 `push()` 메소드는 Route 객체도 사용
    - Route? Android의 Activity와 같은 용어
    - Flutter에서 Route 또한 위젯
- `MaterialPageRoute` 객체는 Material Design의 전환 애니메이션을 지정하는 Route의 하위 클래스

### 화면 전환 방법

1. 두개의 route 생성
    
    ```dart
    class **FirstRoute** extends StatelessWidget {
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(
            title: Text('First Route'),
          ),
          body: Center(
            child: RaisedButton(
              child: Text('Open route'),
              **onPressed: () {
                // 눌렀을 때 두 번째 route로 이동합니다.
              },**
            ),
          ),
        );
      }
    }
    
    class **SecondRoute** extends StatelessWidget {
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(
            title: Text("Second Route"),
          ),
          body: Center(
            child: RaisedButton(
              **onPressed: () {
                // 눌렀을 때 첫 번째 route로 되돌아 갑니다.
              },**
              child: Text('Go back!'),
            ),
          ),
        );
      }
    }
    ```
    
2. `Navigator.push()`를 사용하여 두 번째 route로 전환
    
    ```dart
    // Within the `FirstRoute` widget
    onPressed: () {
      Navigator.**push**(
        context,
        MaterialPageRoute(builder: **(context) => SecondRoute()**),
      );
    }
    ```
    
    - `push()` 메소드는 Route를 Navigator에 의해 관리되는 route 스택에 추가
    
3. `Navigator.pop()`을 사용하여 첫 번째 route로 되돌아옴
    
    ```dart
    // Within the SecondRoute widget
    onPressed: () {
      Navigator.pop(context);
    }
    ```
    
    - 두 번째 route를 닫고 이전 route로 되돌아가려면 Navigator.pop() 메소드 사용
    - `pop()` 메소드는 Navigator에 의해 관리되는 route 스택에서 현재 route를 제거
    

## Using named routes

간단한 탐색 및 깊은 link 요구 사항이 있는 애플리케이션은 탐색을 위하여 Navigator를 사용하고, 깊은 link를 위해 `MaterialApp.routes` 매개 변수를 사용할 수 있다.

```dart
@override
  Widget build(BuildContext context) {
  return **MaterialApp**(
    **routes**: {
      **'/': (context) => HomeScreen(),
      '/details': (context) => DetailScreen(),**
    },
  );
}
```

- 이름 있는 route는 깊은 link를 처리할 수 있지만 동작은 항상 동일하기 때문에 사용자 정의 불가능
- 플랫폼에서 새로운 deep link를 수신하면 현재 사용자가 어느 route에 있든지 간에 새 경로를 Navigator에 밀어 넣음
- Flutter는 이름 있는 route를 사용하는 애플리케이션에 대하여 브라우저 전달 button을 지원하지 않음

⇒ 대부분의 어플리케이션에서 이름 있는 route를 사용하는 것을 권장하지 않음

### 화면 전환 방법

```dart
MaterialApp(
  // "/"으로 named route와 함께 시작합니다. 본 예제에서는 FirstScreen 위젯에서 시작합니다.
  initialRoute: '/',
  routes: {
    // "/" Route로 이동하면, FirstScreen 위젯을 생성합니다.
    **'/': (context) => FirstScreen()**,
    // "/second" route로 이동하면, SecondScreen 위젯을 생성합니다.
    **'/second': (context) => SecondScreen()**,
  },
);

// `FirstScreen` 위젯의 콜백
onPressed: () {
  // Named route를 사용하여 두 번째 화면으로 전환합니다.
  Navigator.**pushNamed(context, '/second')**;
}
```

### 새로운 화면으로 데이터 보내기

1. Todo 클래스 정의
    
    ```dart
    class Todo {
      final String title;
      final String description;
    
      Todo(this.title, this.description);
    }
    ```
    
2. Todo 리스트 보여주기
    
    ```dart
    final todos = List<Todo>.generate(
      20,
      (i) => Todo(
            'Todo $i',
            'A description of what needs to be done for Todo $i',
          ),
    );
    
    **ListView**.builder(
      itemCount: todos.length,
      itemBuilder: (context, index) {
        return **ListTile**(
          title: Text(todos[index].title),
        );
      },
    );
    ```
    
3. Todo에 대한 상세 정보를 보여줄 수 있는 화면을 생성
    
    ```dart
    class DetailScreen extends StatelessWidget {
      // Todo를 들고 있을 필드를 선언합니다.
      final Todo todo;
    
      // 생성자 매개변수로 Todo를 받도록 강제합니다.
      DetailScreen({Key key, **@required this.todo**}) : super(key: key);
    
      @override
      Widget build(BuildContext context) {
        // UI를 그리기 위해 Todo를 사용합니다.
        return Scaffold(
          appBar: AppBar(
            title: Text(todo.title),
          ),
          body: Padding(
            padding: EdgeInsets.all(16.0),
            child: Text(todo.description),
          ),
        );
      }
    }
    ```
    
4. 상세 화면으로 이동하면서 데이터 전달
    
    ```dart
    **ListView**.builder(
      itemCount: todos.length,
      itemBuilder: (context, index) {
        return ListTile(
          title: Text(todos[index].title),
          // 사용자가 ListTile을 선택하면, DetailScreen으로 이동합니다.
          // DetailScreen을 생성할 뿐만 아니라, 현재 todo를 같이 전달해야
          // 한다는 것을 명심하세요.
          onTap: () {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => **DetailScreen(todo: todos[index])**,
              ),
            );
          },
        );
      },
    );
    ```
    

### 이전 화면에 데이터 반환하기

`pop()`에 값 전달

```dart
RaisedButton(
  onPressed: () {
    // Yep 버튼은 결과로 "Yep!"을 반환합니다.
    **Navigator.pop(context, 'Yep!');**
  },
  child: Text('Yep!'),
);

RaisedButton(
  onPressed: () {
    // Nope 버튼은 결과로 "Nope!"을 반환합니다.
    **Navigator.pop(context, 'Nope!');**
  },
  child: Text('Nope!'),
);

_navigateAndDisplaySelection(BuildContext context) async {
  final result = await Navigator.push(
    context,
    MaterialPageRoute(builder: (context) => SelectionScreen()),
  );

  // 선택 창으로부터 결과 값을 받은 후, 이전에 있던 snackbar는 숨기고 새로운 결과 값을
  // 보여줍니다.
  **Scaffold.of(context)
    ..removeCurrentSnackBar()
    ..showSnackBar(SnackBar(content: Text("$result")));**
}
```

## Using the Router

고급 탐색 및 라우팅 요구 사항이 있는 Flutter 애플리케이션은 앱이 새로운 deep link를 수신할 때마다 경로를 구문 분석하고 Navigator를 구성할 수 있는 go_router와 같은 라우팅 패키지 사용

Router를 사용하려면 MaterialApp 또는 CupertinoApp에서 라우터 생성자로 전환하고 라우터 구성을 제공

```dart
MaterialApp.router(
  routerConfig: GoRouter(
    // …
  )
);
```

- go_router와 같은 라우팅 패키지는 일반적으로 사용자를 위한 구성을 제공하는데, 이러한 패키지는 선언적이기 때문에 deep link가 수신될 때 항상 동일한 화면을 표시한다.

## Using Router and Navigator together

- go_router와 같은 선언적 라우팅 패키지를 통해 라우터 API를 사용하여 탐색하거나 navigator에서 `push()` 및 `pop()`과 같은 명령형 메소드를 호출하여 탐색할 수 있음
- 라우터 또는 선언적 라우팅 패키지를 사용하여 탐색할 때 navigator의 각 라우트는 page-backed됨 → navigator 생성자의 페이지 인수를 사용하여 페이지에서 작성됨
- `Navigator.push` 또는 showDialog를 호출하여 만든 Route는 페이지가 없는 경로를 Navigator에 추가
- 라우팅 패키지를 사용하는 경우 page-backed 되는 라우트는 항상 deep link가 가능하지만 페이지가 없는 라우트는 그렇지 않음
- page-backed 되는 라우트 Navigator에서 제거되면 페이지가 없는 모든 route도 제거됨

---

# Deep linking

URL을 열면 해당 화면이 앱에 표시

이름이 지정된 경로(routes 매개변수 또는 GenerateRoute)를 사용하거나 라우터 위젯을 사용하여 경로를 표시하고 시작할 수 있음

## Enable deep linking on Android

안드로이드의 deep link = Intent filter

```xml
<!-- Deep linking -->
<meta-data android:name="flutter_deeplinking_enabled" android:value="true" />
<intent-filter android:autoVerify="true">
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />
    <data android:scheme="http" android:host="flutterbooksample.com" />
    <data android:scheme="https" />
</intent-filter>
```

---

# Configuring the URL strategy on the web

플러터 웹 앱은 웹에서 URL 기반 탐색을 구성하는 2가지 방법을 지원

1. Hash (default)
    
    `flutterexample.dev/**#**/path/to/screen`
    
2. Path
    
    `flutterexample.dev/path/to/screen`****
    

## Configuring the URL strategy

path를 대신 사용하도록 Flutter를 구성하려면 SDK의 flutter_web_plugins 라이브러리에서 제공하는 `usePathUrlStrategy()` 메소드를 사용

```dart
import 'package:flutter_web_plugins/url_strategy.dart';

void main() {
  usePathUrlStrategy();
  runApp(ExampleApp());
}
```

## Hosting a Flutter app at a non-root location

web/index.html의 `<base href = “/”>` 태그를 앱이 호스팅되는 경로로 업데이트함

ex) my_app.dev/slots_app에서 Flutter 앱을 호스팅하려면 태그를 `<base href = “/slots_app/”>`으로 변경

---

# GetX

주요 기능

1. 상태 관리
2. 라우트 관리
3. 종속성 관리

---

# Using Actions and Shortcuts

## Shortcuts

위젯 계층에 삽입되어 해당 키 조합을 누를 때, 사용자의 의도를 나타내는 키 조합을 정의

키 조합에 대한 의도된 목적을 구체적인 action으로 변환하기 위해 actions 위젯은 action에 intent를 매핑하는데 사용됨

```dart
@override
Widget build(BuildContext context) {
  return **Shortcuts**(
    **shortcuts: <LogicalKeySet, Intent>**{
      LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyA):
          **SelectAllIntent()**,
    },
    child: **Actions**(
      dispatcher: LoggingActionDispatcher(),
      actions: <Type, Action<Intent>>{
        **SelectAllIntent: SelectAllAction(model)**,
      },
      child: Builder(
        builder: (context) => TextButton(
          child: const Text('SELECT ALL'),
          **onPressed: Actions.handler<SelectAllIntent>(
            context,
            SelectAllIntent()**,
          ),
        ),
      ),
    ),
  );
}
```

- `SelectAllIntent`를 정의하고 자신의 `SelectAllAction` 또는 `CanvasSelectAllAction`에 바인딩할 수 있음
- 해당 하나의 키 바인딩에서 시스템은 애플리케이션의 어느 부분에 초점이 있는지에 따라 둘 중 하나 호출
- ShortCut 위젯에 제공된 맵은 LogicalKeySet을 Intent 인스턴스에 매핑
- LogicalKeySet은 하나 이상의 키 집합을 정의하며, Intent는 keypress의 의도된 목적을 찾아냄
- Shortcut 위젯은 맵에서 keypress를 찾아 Actions의 `invoke()` 메소드에 제공하는 Intent 인스턴스를 찾음

## Actions

Actions은 애플리케이션이 intent와 함께 호출하여 수행할 수 있는 작업을 정의

Actions는 활성화하거나 비활성화할 수 있으며 Actions을 호출한 intent instance를 argument로 수신하여 intent에 의한 구성을 허용

### Defining actions

가장 간단한 형태의 actions은 `invoke()` 메소드가 있는 `Action<Intent>`의 하위 클래스

```dart
class SelectAllAction extends **Action<SelectAllIntent>** {
  SelectAllAction(this.model);

  final Model model;

  @override
  void **invoke**(covariant SelectAllIntent intent) => model.selectAll();
}
	//or
	CallbackAction(onInvoke: (intent) => model.selectAll());
```

action이 있으면 Actions 위젯을 사용하여 애플리케이션에 추가. 이 위젯은 intent 유형을 Actions에 매핑

```dart
@override
**Widget** build(BuildContext context) {
  return **Actions**(
    actions: <Type, Action<Intent>>{
      SelectAllIntent: SelectAllAction(model),
    },
    child: child,
  );
}
```

- shortcuts 위젯은 Focus 위젯의 context와 어떤 action을 호출할지 찾는 Actions.invoke를 사용
- 만약 Shortcuts 위젯이 처음 발견한 Actions 위젯에서 일치하는 Intent 유형을 찾지 못하면 위젯 트리의 루트에 도달할 때까지 다음 상위 Actions 위젯 등을 고려하거나 일치하는 Intent 유형을 찾아 해당 작업을 호출

### Invoking Actions

Actions 시스템에는 Actions를 호출하는 여러가지 방법

1. shortcut 위젯을 사용
2. Action subsystem을 심문???하고 action을 호출

→ 키에 바인딩되지 않은 작업을 호출 할 수 있음

---

# Keyboard focus system

---

# Taps, drags and other gestures

## Pointers

사용자가 디바이스의 스크린과 상호작용하는 것에 대한 원시데이터

| PointerDownEvent | 특정 위치의 화면에 연결 (터치) |
| --- | --- |
| PointerMoveEvent | 화면의 한 위치에서 다른 위치로 이동 |
| PointerUpEvent | 화면과의 접촉 중지 (터치떼기) |
| PointerCancleEvent | 입력 없음 |
- 포인터 down 시 프레임워크는 앱에서 hit 테스트를 수행하여 포인터가 화면에 접촉한 위치에 어떤 위젯이 있는지 확인
- PointerDownEvent가 hit 테스트에 의해 발견된 가장 안쪽 위젯으로 발송
- 가장 안쪽 위젯에서 트리의 루트까지의 경로에 있는 모든 위젯으로 발송
- 포인터 이벤트가 더 이상 발송되지 않도록 취소하거나 중지하는 메커니즘 X
- 위젯 레이어에서 직접 포인터 이벤트를 수신하려면 Listener 위젯 사용

## Gestures

여러 개의 개별 포인터 이벤트, 심지어 여러 개의 개별 포인터 이벤트로부터 인식되는 의미론적 동작(ex. 탭, 드래그, 스케일)

제스처는 제스처의 수명 주기에 해당하는 여러 이벤트(ex. 끌기 시작, 끌기 업데이트, 끌기 끝)를 발송

### Tap

| onTapDown | 탭을 유발할 수 있는 포인터가 특정 위치의 화면에 닿음 (손닿기) |
| --- | --- |
| onTapUp | 탭을 유발하는 포인터가 특정 위치에서 화면에 연결되는 것을 중지 (손떼기) |
| onTap | 이전에 TapDown에서 유발한 포인터가 TapUp에서도 유발하여 탭이 발생 (닿았다떼기?) |
| onTapCancel | 이전에 TapDown에서 유발한 포인터는 탭을 유발하지 않음 (정확하지 않음) |

### Double tap

| onDoubleTap | 사용자가 동일한 위치의 화면을 빠르게 두 번 연속 두드림 |
| --- | --- |

### Long press

| onLongPress | 포인터가 오랜 시간 동안 같은 위치의 화면과 접촉 |
| --- | --- |

### Vertical drag

| onVerticalDragStart | 포인터가 화면에 접촉하여 수직으로 이동하기 시작 |
| --- | --- |
| onVerticalDragUpdate | 화면과 접촉하여 수직으로 이동하는 포인터가 수직 방향으로 이동 |
| onVerticalDragEnd | 이전에 화면과 접촉하고 수직으로 이동하던 포인터가 더 이상 화면과 접촉하지 않고 특정 속도로 이동하다가 화면과 접촉을 멈춤 |

### Horizontal drag

| onHorizontalDragStart | 포인터가 화면에 접촉하여 수평으로 이동하기 시작 |
| --- | --- |
| onHorizontalDragUpdate | 화면과 접촉하여 수평으로 이동하는 포인터가 수평 방향으로 이동 |
| onHorizontalDragEnd | 이전에 화면과 접촉하고 수평으로 이동하던 포인터가 더 이상 화면과 접촉하지 않고 특정 속도로 이동하다가 화면과 접촉을 멈춤 |

### Pan

| onPanStart | 포인터가 화면에 접촉하여 수평 또는 수직으로 이동하기 시작할 수 있음. 이 콜백은 onHorizontalDragStart 또는 onVertivalDragStart가 설정된 경우 충돌 발생 |
| --- | --- |
| onPanUpdate | 화면에 접촉하여 수직 또는 수평으로 이동하는 포인터. 이 콜백은 onHorizontalDragUpdate 또는 onVerticalDragUpdate가 설정된 경우 충돌 발생 |
| onPanEnd | 이전에 화면과 접촉했던 포인터는 더 이상 화면과 접촉하지 않으며 화면과 접촉을 멈추면 특정 속도로 이동. 이 콜백은 onHorizontalDragEnd 또는 onVerticalDragEnd가 설정된 경우 충돌 발생 |

## Adding Gesture detection to widgets

위젯에 제스처 탐지 시 `GestureDetector` 사용

Material Components를 사용하는 경우 대부분의 위젯은 이미 탭이나 제스처에 응답

## Gesture disambiguation

화면의 지정된 위치에 `GestureDetector`가 여러 개 있을 수 있음. 이러한 모든 `GestureDetector`는 포인터 이벤트가 지나갈 때 해당 이벤트의 스트림을 수신하고 특정 제스처를 인식하려고 시도

`GestureDetector` 위젯은 해당 콜백 중 Null이 아닌 것을 기준으로 인식을 시도할 제스처를 결정

화면상에 주어진 포인터에 대해 하나 이상의 GestureDetector가 있는 경우, 프레임워크는 각각의 Detector가 제스처 영역에 결합하도록 함으로써 사용자가 의도하는 제스처를 명확하게 한다.

Gesture Arena는 다음 규칙을 사용하여 어떤 제스처가 우위인지 결정

- 언제든지 recognizer는 패배를 선언하고 Arena를 떠날 수 있다. 경기장에 recognizer가 한 명만 남아있다면, 그 recognizer가 승리
- 언제든지 recognizer는 승리를 선언할 수 있으며, 이로 인해 나머지 recognizer는 모두 패배

Ex) 수평 및 수직 드래그 → 두 recognizer는 PointerDown 이벤트를 수신할 때 Arena 입장

recognizer들은 포인터 이동 이벤트들을 관찰

사용자가 포인터를 일정 수 이상의 논리 픽셀을 수평으로 움직이면 수평 recognizer가 승리를 선언하고 제스처는 수평 드래그로 해석

제스처 영역은 수평(또는 수직) 드래그 recognizer만 있을 때 유용

---

# Using slivers to achieve fancy scrolling

sliver는 스크롤 가능한 영역의 일부, 특별한 방식으로 동작하도록 정의 가능

sliver를 사용하여 탄성 스크롤과 같은 사용자 지정 스크롤 효과를 얻을 수 있음

## Resources

- [`Slivers, Demystified`](https://medium.com/flutter/slivers-demystified-6ff68ab0296f)
- `[SliverAppBar](https://api.flutter.dev/flutter/material/SliverAppBar-class.html)`
- `[SliverGrid](https://api.flutter.dev/flutter/widgets/SliverGrid-class.html)`
- `[SliverList](https://api.flutter.dev/flutter/widgets/SliverList-class.html)`

---

# Adding a splash screens to your mobile app

## Android launch screen

Android에서는 Android 앱이 초기화되는 동안 표시되는 시작 화면과 Flutter 환경이 초기화되는 동안 표시되는 시작 화면 두 가지 개별 화면 제어 가능

### Initializing the app

모든 Android 앱은 운영체제가 앱의 프로세스를 설정하는 동안 초기화 시간이 필요

Android는 앱이 초기화되는 동안 Drawable을 표시하는 시작 화면 개념을 제공

```xml
<style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
    <item name="android:windowBackground">@drawable/launch_background</item>
</style>
```

- `styles.xml` 을 편집하여 사용자 정의 할 수 있으며, 여기서 windowBackground가 시작화면으로 표시되어야하는 Drawable로 설정된 테마 정의 가능

```xml
<style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
    <item name="android:windowBackground">@drawable/normal_background</item>
</style>
```

- `styles.xml` 은 실행화면이 사라진 후 `FlutterActivity`에 적용할 일반 테마를 정의
- 일반 테마 배경은 스플래시 화면이 사라지고 방향 변경 및 활동 복원 중에 매우 짧은 순간 동안만 표시
- 일반 테마는 Flutter UI의 기본 배경색과 유사한 솔리드 배경색을 사용하는 것이 좋음

### Set up the FlutterActivity in AndroidManifest.xml

```xml
<activity
    android:name=".MyActivity"
    android:theme="@style/LaunchTheme"
    // ...
    >
    <meta-data
        android:name="io.flutter.embedding.android.NormalTheme"
        android:resource="@style/NormalTheme"
        />
    <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
    </intent-filter>
</activity>
```

- AndroidManifest.xml에서 FlutterActivity 테마를 시작 테마로 설정
- 메타데이터 요소를 원하는 FlutterActivity에 추가하여 적절한 시간에 시작테마에서 일반 테마로 전환하도록 Flutter에 지시

---

# Animation

## Animation types

### Tween animation

애니메이션 사이에서 시작점과 끝점, 타임라인, 전환 시기와 속도를 정의하는 곡선이 정의됨.

프레임워크는 시작점에서 끝점으로 전환하는 방법을 계산

### Physics-based animation

모션이 실제 행동과 유사하게 모델링

## Animation class

애니메이션은 애니메이션의 수명 동안 변경될 수 있는 특정 유형의 값을 나타냄.

애니메이션을 수행하는 대부분의 위젯은 애니메이션 개체를 매개변수로 수신하며, 이 매개 변수에서 애니메이션의 현재 값을 읽고 해당 값의 변경 내용을 수신

- `addListener`
    
    애니메이션의 값이 변경될 때마다 애니메이션은 `addListener`로 추가된 모든 listener에게 알림. 일반적으로 애니메이션을 listen하는 state object는 listener 콜백에서 `setState`로 위젯 시스템에 애니메이션의 새 값으로 재구성해야함을 알림
    
    - `AnimatedWidget`은 Stateless 애니메이션 위젯에 가장 유용. `AnimatedWidget`을 사용하려면 해당 위젯을 하위분류하고 빌드 기능을 구현
    - `AnimatedBuilder`는 더 큰 빌드 기능의 일부로 애니메이션을 포함하려는 더 복잡한 위젯에 유용. `AnimatedBuilder`를 이용하려면 위젯을 구성하고 빌더 기능을 전달

- `addStatusListener`
    
    애니메이션은 시간이 지남에 따라 애니메이션이 어떻게 발전하는지를 나타내는 AnimationStatus를 제공. 애니메이션의 상태가 변경될 때마다 애니메이션은 AddStatusListener로 추가된 모든 listener에 알림. 일반적으로 애니메이션은 해제된 상태에서 시작되는데, 이는 애니메이션이 범위의 시작에 있다는 것을 의미.(0, 0)
    

## AnimationController

애니메이션을 만들기 위해 먼저 `AnimationController`를 만듬. `AnimationController`를 사용하면 애니메이션 자체일뿐만 아니라 애니메이션을 제어할 수 있음.

EX) 컨트롤러에게 애니메이션을 앞으로 재생하거나 중지하도록 지시할 수 있음

`AnimationController`를 만든 후 이 컨트롤러를 기반으로 다른 애니메이션 빌드 가능.

EX) 원래 애니메이션을 미러링하지만, 반대 방향으로 실행되는 Reverse Animation을 만들 수 있음.

## Tweens

0.0에서 1.0 구간을 넘어서 애니메이션을 만들려면 시작 값과 끝 값 사이를 보간하는 `Tween<T>`를 사용할 수 있음.

EX) `ColorTween`은 rect 사이를 보간. `Tween`의 하위 클래스를 만들고 `lerp` 함수를 재정의하여 자체 보간을 정의할 수 있음.

두 값 사이를 보간하는 방법을 정의

1. 애니메이션의 현재 값으로 tween 측정 가능. 이미 애니메이션을 listen 중인 위젯에 가장 유용하므로 애니메이션이 값을 변경할 때마다 재구성 가능.
2. 애니메이션을 기반으로 tween 애니메이션화 가능. 애니메이션 기능은 단일 값을 반환하는 대신 두 값을 통합한 새 애니메이션을 반환. 이 방법은 새로 만든 애니메이션을 다른 위젯에 제공할 때 가장 유용. 위젯은 값의 변경 내용을 수신할 뿐만 아니라 값을 통합하는 현재 값을 읽을 수 있음

## Animation Tutorial

### animation<double>

애니메이션 개체는 화면에 표시되는 내용에 대해 아무것도 알지 못함. 애니메이션은 현재 값과 state(완료 또는 해제됨)를 이해하는 추상 클래스.

애니메이션 개체는 특정 기간 동안 두 값 사이에 보간된 숫자를 순차적으로 생성함. 애니메이션 개체의 출력은 선형, 곡선, 단계 함수 또는 고안할 수 있는 다른 매핑일 수 있음. 애니메이션 개체가 제어되는 방식에 따라 역방향으로 실행되거나 중간에 방향을 전환할 수도 있음.

애니메이션은 `Animation<color>`, `Animation<size>`와 같이 double이 아닌 다른 유형을 보간할 수도 있음.

애니메이션 개체는 렌더링 또는 `build()` 함수에 대해 아무것도 모름.

### AnimationController

: 하드웨어가 새 프레임을 준비할 때마다 새 값을 생성하는 특수 애니메이션 개체

: 기본적으로 `AnimationController`는 주어진 기간 동안 0.0에서 1.0까지의 숫자를 선형적으로 생성

```dart
controller =
    AnimationController(duration: const Duration(seconds: 2), vsync: this);
```

- `AnimationController`는 `Animation<double>`에서 파생되므로 애니메이션 개체가 필요한 곳이면 어디에서나 사용할 수 있음
- 애니메이션을 제어하는 추가 방법으로 `forward()` 메소드로 애니메이션을 시작. 숫자 생성은 화면 새로고침에 연결되므로 일반적으로 초당 60개의 숫자가 생성. 각 숫자가 생성된 후 각 애니메이션 개체는 연결된 listener 개체를 호출. 각 하위 항목에 대한 사용자 지정 화면 표시 목룍을 만들려면 `RepaintBoundary` 참조
- `AnimationController`를 생성할 때 vSync 인수를 전달함. vSync가 있으면 오프스크린 애니메이션이 불필요한 리소스를 소비하지 않음.
- `SingleTickerProviderStateMixin`을 클래스 정의에 추가하여 상태 저장 개체를 vSync로 사용할 수 있음