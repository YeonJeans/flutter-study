# 1주차 스터디

# Dart 언어 학습

### Dart 공식문서 + 책

공식문서 : [https://dart.dev/guides/language/language-tour](https://dart.dev/guides/language/language-tour)

책 : [https://ridibooks.com/books/3419000002](https://ridibooks.com/books/3419000002) (pg 64 ~ 100)

코틀린과 다른 점에 대해서 정리

- 전반적으로 코틀린과 비슷한 양상
    - 타입 추론 가능
    - 콜론 뒤에 타입 삽입

- 다른 점
    - 세미콜론 (;) 꼭 붙여야 함
    
    - `var` : 유형을 지정하지 않고 변수를 선언하는 방법
        - 단일 유형으로 지정하지 않을 경우 `object` 사용
    - public, protected, private 키워드가 없음 → 식별자가 밑줄(_)로 시작하는 경우 해당 라이브러리에서 private 한 것
    - nullable하면서 초기화되지 않은 변수 & 숫자 타입 변수의 초기값은 null
    ex) `int? lineCount;`
    - 선언 후에 초기화 되는 nullable이 아닌 변수를 선언할 때 `late` 
    → late 변수를 초기화하지 않고 사용하면 런타임 에러 발생
    ex) `late String temperature = readThermometer();` : `readThermometer()` 함수가 호출될 때 초기화
    - 변수 고정 시 var 대신 `final` 또는 `const` 
    → compile-time constants 일 때 `const` 사용
    → 상수 변수 선언 뿐만 아니라 상수 값을 만들 때도 사용 가능
    ex) `var foo = const [];`
    
    - 변수를 `num`으로 선언할 경우 변수는 `int`와 `double` 값 모두 가질 수 있음
    - `string` 을 여러 줄로 사용하고 싶을 경우 ‘’’ ‘’’(””” “””) 사용
    - r을 접두사로 붙여 raw 문자열 생성 가능
    - collection에 여러 값을 삽입할 때 스프레드 연산자(…) 및 null 인식 스프레드 연산자(…?) 사용
    스프레드 연산자 : 목록의 모든 값을 다른 목록에 삽입 가능
    null 인식 스프레드 연산자 : 스프레드 연산자의 오른쪽 식을 null로 지정하면 예외 방지 가능
    - 리스트에 `Collection if` / `Collection for` 사용 가능
    - Runes : 문자열의 유니코드 코드 포인트를 노출
    개별 유니코드 문자를 읽거나 쓰려면 character 패키지별 문자열에 정의된 getter 사용
        
        ```dart
        import 'package:characters/characters.dart';
        
        void main() {
          var hi = 'Hi 🇩🇰';
          print(hi);
          print('The end of the string: ${hi.substring(hi.length - 1)}');
          print('The last character: ${hi.characters.last}');
        }
        ```
        
    - Symbol : Dart 프로그램에서 선언된 연산자 또는 식별자
    # + 식별자 이름
    
    - **함수도 객체로 사용 가능 → 함수를 변수에 할당하거나 다른 함수에 인수로 전달하거나 Dart 클래스의 인스턴스를 호출할 수 있음**
    - 함수 한 줄이면 ⇒ `{ return *expr*; }` 로 표현가능
    - 매개변수를 필수로 지정하고 꼭 매개 변수 값을 제공하도록 하려면 `required` 주석 사용
    → 필수로 표시된 매개변수도 ?붙이면 null일수도 있다
    - 매개변수를 []로 감싸면 선택적 위치 매개변수로 표시, 기본값 null이므로 nullable 하게
    - **Functions as first-class objects** → 람다 함수 같은 느낌
        
        ```dart
        var loudify = (msg) => '!!! ${msg.toUpperCase()} !!!';
        assert(loudify('hello') == '!!! HELLO !!!');
        ```
        
    - 익명함수 → 형식이 지정되지 않은 매개변수, 항목이 있는 매개변수를 정의하고 전달
        
        ![Untitled](1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20162afc445b0748d6a408f69310a75f6e/Untitled.png)
        
        ```dart
        const list = ['apples', 'bananas', 'oranges'];
        list.map(**(item) {
          return item.toUpperCase();
        }**).forEach(**(item) {
          print('$item: ${item.length}');
        }**);
        
        list
            .map((item) **=>** item.toUpperCase())
            .forEach((item) **=>** print('$item: ${item.length}'));
        ```
        
    - type 테스트 연산자
        
        
        | 운영자 | 의미 |
        | --- | --- |
        | as | Typecast |
        | is | 객체에 지정된 type이 있는 경우 true |
        | is! | 객체에 지정된 type이 없는 경우 true |
    - **Cascade notation (.., ?..)**
    동일한 객체에서 일련의 연산 수행 가능
    인스턴스 멤버에 접근 / 동일한 개체에서 인스턴스 메소드 호출 가능
    개체가 null일 수 있다면 맨 처음에 ?.. 사용
        
        ```dart
        var paint = Paint()
          ..color = Colors.black
          ..strokeCap = StrokeCap.round
          ..strokeWidth = 5.0;
        ```
        
        ⇒ paint.~로 접근하지 않아도 된다
        중첩 cascade도 가능
        
    - `assert` : 조건이 false일 경우 실행 중단
    - 일부 클래스는 상수 생성자 제공 ⇒ `var p = const ImmutablePoint(2, 2);` 
    상수 생성자를 넣은 객체와 아닌 객체는 다른 인스턴스
    - instance variable
    모든 instance variable은 암시적 getter 생성
    초기화가 없는 non-final instance variable과 late final instance variable은 암시적 setter 생성
    final일 경우 선언 시 생성자 매개 변수를 사용하거나 생성자의 초기화 목록을 이용하여 인스턴스 변수 초기화
    
    - 생성자로 초기화 시, 생성자 인수를 그대로 인스턴스 변수에 할당해도 된다. = 매개변수에 넣어도 된다는 뜻
    - 하위 클래스는 해당 슈퍼 클래스에서 생성자를 상속하지 않는다. 오로지 기본 생성자만
    - 생성자에 이름을 부여하여 여러 생성자를 구현하거나 명확성을 추가할 수 있음
        
        ```dart
        const double xOrigin = 0;
        const double yOrigin = 0;
        
        class Point {
          final double x;
          final double y;
        
          Point(this.x, this.y);
        
          // Named constructor
          **Point.origin()**
              : x = xOrigin,
                y = yOrigin;
        }
        ```
        
    - 하위 클래스 생성자는 슈퍼 클래스의 이름 없는 생성자를 호출함.
    슈퍼클래스에 이름 없는 생성자가 없으면 하위 클래스에서는 슈퍼클래스의 생성자 중 하나를 수동을 호출. 콜론 뒤로 슈퍼클래스 생성자 지정
    호출 순서 : 이니셜라이저 리스트 → 슈퍼클래스의 생성자 → 메인 클래스의 생성자
    - 생성자의 본문이 실행되기 전에 인스턴스 변수 먼저 초기화 가능, 쉼표로 구분
        
        ```dart
        // Initializer list sets instance variables before
        // the constructor body runs.
        Point.fromJson(Map<String, double> json)
            : **x = json['x']!,
              y = json['y']!** {
          print('In Point.fromJson(): ($x, $y)');
        }
        ```
        
        - 초기화 할 때 assert를 이용하여 유효성 검사 가능
            
            ```dart
            Point.withAssert(this.x, this.y) : **assert(x >= 0)** {
              print('In Point.withAssert(): ($x, $y)');
            }
            ```
            
    - **redirecting constructors**
    같은 클래스의 다른 생성자로 리디렉션할 때, 생성자의 본문은 비어있으며 생성자 호출은 콜론 뒤에
        
        ```dart
        class Point {
          double x, y;
        
          // The main constructor for this class.
          Point(this.x, this.y);
        
          // Delegates to the main constructor.
          Point.alongXAxis(double x) **: this(x, 0)**;
        }
        ```
        
    - **factory constructors**
    클래스의 새 인스턴스를 항상 만들지 않는 생성자를 구현할 때 factory 키워드 사용
    ex) 캐시에서 인스턴스 반환, 하위 유형의 인스턴스 반환
        
        ```dart
        factory Logger(String name) {
            return _cache.putIfAbsent(name, () => Logger._internal(name));
          }
        
          factory Logger.fromJson(Map<String, Object> json) {
            return Logger(json['name'].toString());
          }
        ```
        
    
    **메소드**
    
    - Getter and Setter
    get 과 set 키워드를 사용하여 원래 없던 추가 속성 생성 가능
        
        ```dart
        class Rectangle {
          double left, top, width, height;
        
          Rectangle(this.left, this.top, this.width, this.height);
        
          // Define two calculated properties: right and bottom.
          **double get right => left + width;
          set right(double value) => left = value - width;
          double get bottom => top + height;
          set bottom(double value) => top = value - height;**
        }
        
        void main() {
          var rect = Rectangle(3, 4, 20, 15);
          assert(rect.left == 3);
          rect.right = 12;
          assert(rect.left == -8);
        }
        ```
        
    - 암시적 인터페이스
    모든 클래스는 클래스의 모든 인스턴스 구성원과 그것이 구현하는 모든 인터페이스를 포함하는 인터페이스를 암시적으로 정의
        
        ```dart
        // A person. The implicit interface contains greet().
        class Person {
          // In the interface, but visible only in this library.
          **final String _name;**
        
          // Not in the interface, since this is a constructor.
          Person(this._name);
        
          // In the interface.
          **String greet(String who) => 'Hello, $who. I am $_name.';**
        }
        
        // An implementation of the Person interface.
        class Impostor **implements Person** {
          **String get _name => '';**
        
          **String greet(String who) => 'Hi $who. Do you know who I am?';**
        }
        
        String greetBob(Person person) => person.greet('Bob');
        
        void main() {
          print(greetBob(Person('Kathy')));
          print(greetBob(Impostor()));
        }
        ```
        
    - `noSuchMethod()` 
    코드가 존재하지 않는 메소드 또는 인스턴스 변수를 사용하려고 시도할 때마다 탐지하거나 반응하려면 override
        
        ```dart
        class A {
          // Unless you override noSuchMethod, using a
          // non-existent member results in a NoSuchMethodError.
          @override
          void **noSuchMethod**(Invocation invocation) {
            print('You tried to use a non-existent member: '
                '${invocation.memberName}');
          }
        }
        ```
        
    
    - **클래스에 기능 추가 : mixins**
    클래스 코드를 여러 클래스 계층에서 재사용하는 방법
    `with` 키워드 뒤에 하나 이상의 혼합 이름을 작성
    `mixin` 구현 시 개체를 확장하고 생성자가 없는 클래스 생성. `class` 키워드 대신 `mixin`사용
        
        ```dart
        class Musician extends Performer **with Musical** {
          // ···
        }
        
        class Maestro extends Person **with Musical, Aggressive, Demented** {
          Maestro(String maestroName) {
            name = maestroName;
            canConduct = true;
          }
        }
        
        **mixin Musical** {
          bool canPlayPiano = false;
          bool canCompose = false;
          bool canConduct = false;
        
          void entertainMe() {
            if (canPlayPiano) {
              print('Playing piano');
            } else if (canConduct) {
              print('Waving hands');
            } else {
              print('Humming to self');
            }
          }
        }
        
        **mixin MusicalPerformer on Musician** {
          // ...
        }
        ```
        
        - `mixin`을 사용할 수 있는 유형 제한 가능, `on` 키워드로 필요한 superclass 지정
    
    **제네릭**
    
    - Restricting the parameterized type
    제네릭 타입을 구현할 때 인수로 제공할 수 있는 **유형을 제한**하여 인수가 특정 유형의 하위 유형임을 지정할 수 있음. 확장 사용
        
        ```dart
        class Foo<**T extends Object**> { //object의 하위 유형으로 지정하여 null 사용 x
          // Any type provided to Foo for T must be non-nullable.
        }
        ```
        
        ```dart
        class Foo<**T extends SomeBaseClass**> {
          // Implementation goes here...
          String toString() => "Instance of 'Foo<$T>'";
        }
        
        class **Extender extends SomeBaseClass** {...}
        
        var someBaseClassFoo = Foo<SomeBaseClass>();
        var extenderFoo = Foo<Extender>();
        ```
        
        - Extender는 SomeBaseClass를 상속받은 하위 클래스이기 때문에 T에 들어갈 수 있음
        - 제네릭 인자 없는건 가능하지만, SomeBaseClass 타입이 아닌 것들은 에러 발생
    
    - Using generic methods
        
        ```dart
        **T** first<**T**>(List<**T**> ts) {
          // Do some initial work or error checking, then...
          **T** tmp = ts[0];
          // Do some additional checking or processing...
          return tmp;
        }
        ```
        
        - 첫번째 : 리턴 타입
        - 두번째 : 인자의 타입 List<T>
        - 세번째 : 로컬 변수의 타입 T tmp
    
    **Libraries and visibility**
    
    - import
        
        ```dart
        import 'dart:html';
        import 'package:test/test.dart';
        ```
        
    - 식별자가 충돌하는 경우 접두사 지정 가능
        
        ```dart
        import 'package:lib1/lib1.dart';
        import 'package:lib2/lib2.dart' **as lib2**;
        
        // Uses Element from lib1.
        Element element1 = Element();
        
        // Uses Element from lib2.
        lib2.Element element2 = lib2.Element();
        ```
        
    - 라이브러리의 일부 파트만 사용하고 싶을 때 선택적 import 가능
        
        ```dart
        // Import only foo.
        import 'package:lib1/lib1.dart' show foo;
        
        // Import all names EXCEPT foo.
        import 'package:lib2/lib2.dart' hide foo;
        ```
        
    - 라이브러리가 필요할 때, 필요에 따라 지연 로드 가능
    1. 웹 앱의 초기 시작 시간을 줄이기 위해서
    2. 예를 들어 알고리즘의 대체 구현을 시도하는 테스트를 수행할 때
    3. 선택적 화면 및 다이얼로그 같이 거의 사용하지 않는 기능 로드할 때
        
        ```dart
        import 'package:greetings/hello.dart' **deferred as hello**;
        
        Future<void> greet() **async** {
          **await** hello.**loadLibrary();**
          hello.printGreeting();
        }
        ```
        
        - 라이브러리가 필요할 때 라이브러리의 식별자를 이용하여 loadLibrary() 호출
    
    **비동기 처리**
    
    - 미래 핸들링
    `await` 를 사용하여 비동기 함수의 결과를 기다림
    `await` 사용 시 코드가 `async` 함수에 있어야 함
        
        ```dart
        Future<void> checkVersion() **async** {
          var version = **await** lookUpVersion();
          // Do something with version
        }
        ```
        
        ```dart
        String lookUpVersion() => '1.0.0';
        **Future**<String> lookUpVersion() **async** => '1.0.0';
        ```
        
        - 비동기 처리를 하면 미래 구현에 시간이 많이 소요되므로 반환되는 값은 Future
    - 비동기 루프
    비동기 루프 구현 시 컴파일 타임 오류 발생하면 await for가 async 함수 안에 있는지 확인할 것
        
        ```dart
        void main() **async** {
          // ...
          **await for** (final request in requestServer) {
            handleRequest(request);
          }
          // ...
        }
        ```