# 4주차 스터디

# State management

## Differentiate between ephemeral state and app state

### Ephemeral state

= UI 상태 또는 로컬 상태

하나의 위젯에 깔끔하게 담을 수 있는 state

- PageView의 현재 페이지
- 복잡한 애니메이션의 현재 진행 상황
- BottomNavigationBar에서 현재 선택한 탭

위젯 트리의 다른 부분에서는 이러한 종류의 state에 대해 접근할 필요가 거의 없다. → 상태 관리 기법(Scoped Model, Redux 등)을 사용할 필요가 없다.

⇒ 우리에게 필요한 것은 **상태 저장 위젯**

```dart
class MyHomepage extends StatefulWidget {
  const MyHomepage({super.key});

  @override
  **State<MyHomepage> createState() => _MyHomepageState();**
}

**class _MyHomepageState extends State<MyHomepage> {
  int _index = 0;**

  @override
  Widget build(BuildContext context) {
    return BottomNavigationBar(
      currentIndex: _index,
      onTap: (newIndex) {
        **setState(() {
          _index = newIndex;
        });**
      },
      // ... items ...
    );
  }
}
```

- 현재 선택한 항목이 _MyHomepageState 클래스의 _index 필드에 보관
- 변수는 MyHomepage 위젯 내부에서만 변경되기 때문에 앱의 다른 부분은 _index에 접근할 필요가 없다.
- 사용자가 앱을 닫고 다시 시작하면 _index가 0으로 재설정되어도 상관 없다.

### App State

= 애플리케이션 상태 또는 공유 상태

일시적이지 않고, 앱의 많은 부분에서 공유하고 싶고, 사용자 세션 사이에 유지하고 싶은 state

- 사용자 기본 설정
- 로그인 정보
- 소셜 네트워킹 앱의 알림
- 전자상거래 앱의 장바구니

### There is no clear-cut rule

clear하기 위해 State랑 `setState()`를 사용하여 앱의 모든 상태를 관리할 수 있음.

그러나 가끔은 다른 방식으로 진행되기도 하는데, 예를 들어 특정 앱의 context에서 BottomNavigationBar에서 선택한 탭이 ephemeral state가 아니라고 결정할 수도 있다. 클래스 외부에서 변경하거나 세션 간에 유지하는 등의 작업이 필요하고, 이 경우 _index 변수는 app state

= 특정 변수가 ephemeral state인지 app state인지를 명확하게 구분하는 보편적 규칙은 없다.

⇒ Flutter 앱에는 두 가지 개념적인 유형의 state가 있는데, ephemeral state는 State 및 `setState()`를 사용하여 구현할 수 있으며, 단일 위젯에 로컬인 경우가 많고, 나머지는 app state다.

## Simple app state management

`provider` 패키지 사용

### Lifting state up

Flutter에서는 상태를 사용하는 위젯 위에 상태를 유지하는 것이 좋다.

→ Flutter와 같은 선언적 프레임워크에서 UI를 변경하려면 재구성해야함.

→ 외부에서 위젯을 메소드 호출로 변경하는 것은 어렵다. (ex. `MyCart.updateWith(new)`)

Flutter에서는 내용이 변경될때마다 새로 위젯을 만들기 때문에 `MyCart(new)`같은 생성자를 사용하는 것이 좋다.

→ 부모의 `build` 메소드에서만 새로운 위젯을 구성할 수 있기 때문에 콘텐츠를 변경하려면 MyCart의 부모 이상에 위치해야 한다.

```dart
// GOOD
void myTapHandler(BuildContext context) {
  **var cartModel = somehowGetMyCartModel(context);**
  cartModel.add(item);
}

// GOOD
Widget build(BuildContext context) {
  **var cartModel = somehowGetMyCartModel(context);**
  return SomeWidget(
    // Just construct the UI once, using the current state of the cart.
    // ···
  );
}
```

- MyCart의 더 상위인 MyApp에 cart 콘텐츠 저장, 변경될 때마다 위에서 MyCart 다시 빌드 → LifeCycle을 걱정할 필요가 없으며 주어진 콘텐츠에 대해 무엇을 표시할지만 선언
- 변경되면 이전 MyCart 위젯이 사라지고 새 위젯으로 완전히 대체됨
- 그래서 위젯이 불변. 수정이 아니라 새 것으로 교체

### Accessing the state

사용자가 카탈로그의 항목 중 하나를 누르면 카트에 추가되는데, 카트가 MyListItem 위에 있으면 어떻게 해야하는가? → MyListItem이 클릭할 때 호출할 수 있는 **콜백**을 제공

```dart
@override
Widget build(BuildContext context) {
  return SomeWidget(
    // Construct the widget, passing it a reference to the method above.
    MyListItem(myTapCallback),
  );
}

**void myTapCallback(Item item) {
  print('user tapped on $item');
}**
```

- 여러 곳에서 수정해야 하는 app state의 경우에는 많은 콜백을 전달해야 함.
- Flutter는 위젯이 자식에게 데이터와 서비스를 제공하는 메커니즘을 가지고 있다.
- 따라서 우리는 provider라는 package를 사용
    - ChangeNotifier
    - ChangeNotifierProvider
    - Consumer

### ChangeNotifier

: 청취자에게 변경 알림 제공

: 무언가가 ChangeNotifier인 경우, 변경 내용을 구독할 수 있음 (=observe)

: provider에서 ChangeNotifier는 응용 프로그램 상태를 캡슐화하는 방법. 따라서 간단한 앱의 경우 단일, 복잡한 앱의 경우 여러 개의 모델이므로 여러 개 필요

```dart
class CartModel extends **ChangeNotifier** {
  /// Internal, private state of the cart.
  final List<Item> _items = [];

  /// An unmodifiable view of the items in the cart.
  UnmodifiableListView<Item> get items => UnmodifiableListView(_items);

  /// The current total price of all items (assuming all items cost $42).
  int get totalPrice => _items.length * 42;

  /// Adds [item] to cart. This and [removeAll] are the only ways to modify the
  /// cart from the outside.
  void add(Item item) {
    _items.add(item);
    // This call tells the widgets that are listening to this model to rebuild.
    **notifyListeners();**
  }

  /// Removes all items from the cart.
  void removeAll() {
    _items.clear();
    // This call tells the widgets that are listening to this model to rebuild.
    **notifyListeners();**
  }
}
```

- ChangeNotifier와 관련된 유일한 코드는 `notifyListeners()`
- 앱의 UI를 변경할 수 있는 방식, 모델이 변경될 때마다 이 메소드 호출

### ChangeNotifierProvider

: 하위 항목에 ChangeNotifier 인스턴스를 제공하는 위젯

: 제공해야 할 곳의 상단에 위치 (예제에서는 상위 위젯이 MyApp으로 유일)

```dart
void main() {
  runApp(
    **ChangeNotifierProvider(**
      create: (context) => CartModel(),
      **child: const MyApp()**,
    ),
  );
}
```

- ChangeNotifierProvider는 절대적으로 필요하지 않는 한 CartModel을 재구성하지 않음.
- 인스턴스가 더 이상 필요하지 않을 때 CartModel에서 `dispose()` 자동 호출

만약 클래스를 두 개 이상 제공하려면 MultiProvider 사용

```dart
void main() {
  runApp(
    **MultiProvider**(
      providers: [
        **ChangeNotifierProvider(create: (context) => CartModel())**,
        **Provider(create: (context) => SomeOtherClass())**,
      ],
      child: const MyApp(),
    ),
  );
}
```

### Consumer

: ChangeNotifierProvider 선언을 통해 CartModel이 앱의 위젯에 제공되기 때문에 사용 시작

: 사용은 Consumer로

```dart
return **Consumer<CartModel>**(
  builder: (context, cart, child) {
    return Text('Total price: ${cart.totalPrice}');
  },
);
```

- 액세스할 모델의 유형을 지정, Consumer는 유형을 기반으로 하기 때문에 정하지 않으면 원하는 것을 알 수 없음
- Builder는 ChangeNotifier가 변경될 때마다 호출되는 기능 (모델에서 `notifyListener()`를 호출할 때 해당하는 모든 Consumer 위젯의 모든 Builder 메소드가 호출됨)

```dart
return Consumer<CartModel>(
  builder: (context, cart, **child**) => Stack(
    children: [
      // Use SomeExpensiveWidget here, without rebuilding every time.
      if (**child** != null) **child**,
      Text('Total price: ${cart.totalPrice}'),
    ],
  ),
  // Build the expensive widget here.
  **child**: const SomeExpensiveWidget(),
);
```

- Builder는 3개의 인수로 호출
    - Context
        
        모든 빌드 메소드에서 얻을 수 있음
        
    - ChangeNotifier의 인스턴스
        
        모델의 데이터를 사용하여 지정된 지점에서 UI의 모양을 정의 가능
        
    - 최적화를 위해 존재하는 child
        
        모델이 변경될 때 변경되지 않는 큰 위젯 하위 트리가 Consumer 아래에 있으면 한 번만 구성하고 Builder를 통해 가져올 수 있음
        

```dart
// DO THIS
return HumongousWidget(
  // ...
  child: AnotherMonstrousWidget(
    // ...
    **child: Consumer<CartModel>(
      builder: (context, cart, child) {
        return Text('Total price: ${cart.totalPrice}');
      },
    ),**
  ),
);
```

- Consumer 위젯을 가능한 한 트리 깊숙이 넣는 것이 가장 좋음. → 어딘가의 세부 사항이 바뀌었다고 해서 UI의 많은 부분을 재구성하고 싶지는 않기 때문에

**Provider.of**

UI를 변경하기 위해 모델의 데이터가 꼭 필요하지는 않지만 그래도 액세스해야 하는 경우가 있음.

ex) ClearCart 버튼을 누르면 사용자가 카트에서 모든 항목을 제거

→ 카트 내용 표시 필요 없이 Clear() 메서드 호출

이를 위해 `Consumer<CartModel>`을 사용할 수는 있지만 낭비

→ 이 경우 `listen` 파라미터를 false로 설정한 상태에서 `Provider.of`를 사용할 수 있음

```dart
Provider.of<CartModel>(context, **listen: false**).removeAll();
```

---

# Networking & http

## JSON and serialization

### Which JSON serializaion method is right for me?

**Use manual serialization for smaller projects**

: 내장 JSON 디코더를 `dart:convert`에서 사용하는 것

: 원시 JSON 문자열을 `jsonDecode()` 함수로 전달한 다음 결과 `Map<String, dynamic>`에서 필요한 값을 찾는 작업 포함

: 프로젝트가 커질경우 수동 JSON 디코딩이 제대로 수행되지 않음 → 디코딩 로직을 손으로 작성하는 것은 관리하기 어렵고 오류가 발생하기 쉽기 때문

**Use code generation for medium to large projects**

: 외부 라이브러리가 인코딩 보일러 플레이트를 생성하도록 하는 것

: 초기 설정 후 모델 클래스에서 File watcher를 실행 → `json_serializable` or `built_value`

### Serializing JSON manually using dart:convert

**Serializing JSON inline**

: JSON 문자열을 method 인수로 jsonDecode() 함수를 호출하여 디코딩

```dart
**Map<String, dynamic>** user = **jsonDecode(jsonString)**;

print('Howdy, ${user['name']}!');
print('We sent the verification link to ${user['email']}.');
```

- jsonDecode()는 Map<String, dynamic>을 반환하기 때문에 실행 시까지 값의 유형을 알 수 없음.
- type safety, autocompletion, compile-time 등과 같은 정적으로 입력된 언어 기능 대부분이 손실

**Serializing JSON inside model classes**

```dart
class User {
  final String name;
  final String email;

  User(this.name, this.email);

  User.fromJson(Map<String, dynamic> json)
      : name = json['name'],
        email = json['email'];

  Map<String, dynamic> toJson() => {
        'name': name,
        'email': email,
      };
}
```

- 필요한 필드를 class로 묶어서 Class.fromJson 사용
- 이 방법 사용 시 호출 코드에 type safety, autocompletion, compile-time 예외가 있을 수 있음
- 디코딩 로직 책임은 모델 자체의 내부로 이동, 사용자 쉽게 해독 가능

### Serializing JSON using code generation libraries

**Setting up json_serializable in a project**

```yaml
dependencies:
  # Your other regular dependencies here
  json_annotation: <latest_version>

dev_dependencies:
  # Your other dev_dependencies here
  build_runner: <latest_version>
  json_serializable: <latest_version>
```

- 프로젝트에 json_serializable 포함 시 종속성 필요
- 개발 종속성 → 앱 소스 코드에 포함되지 않은 종속성, 개발 환경에서만 사용

**Creating model classes the json_serializable way**

```dart
**import 'package:json_annotation/json_annotation.dart';**

/// This allows the `User` class to access private members in
/// the generated file. The value for this is *.g.dart, where
/// the star denotes the source file name.
part 'user.g.dart';

/// An annotation for the code generator to know that this class needs the
/// JSON serialization logic to be generated.
**@JsonSerializable()**
class User {
  User(this.name, this.email);

  String name;
  String email;

  /// A necessary factory constructor for creating a new User instance
  /// from a map. Pass the map to the generated `_$UserFromJson()` constructor.
  /// The constructor is named after the source class, in this case, User.
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);

  /// `toJson` is the convention for a class to declare support for serialization
  /// to JSON. The implementation simply calls the private, generated
  /// helper method `_$UserToJson`.
  Map<String, dynamic> toJson() => _$UserToJson(this);
}
```

- 소스 코드 생성기가 JSON에서 필드를 인코딩하고 디코딩하기 위한 코드 생성

```dart
/// Tell json_serializable that "registration_date_millis" should be
/// mapped to this property.
**@JsonKey(name: 'registration_date_millis')**
final int registrationDateMillis;
```

- 필요한 경우 이름 지정 전략을 @JsonKey 주석을 이름 매개변수와 함께 사용하여 사용자 정의
- 서버와 클라이언트 모두 동일한 이름 지정 전략을 사용하는 것이 가장 좋음

**Running the code generation utility**

프로젝트 루트에서 `flutter pub run build_runner build —delete-conflicting-outputs` 를 실행하면 필요할 때마다 모델에 대한 JSON Serialization 코드를 생성할 수 있음

→ 소스 파일을 통과하는 일회성 빌드를 트리거하고, 관련 파일을 선택하고, 해당 파일에 필요한 Serialization 코드를 생성

Watcher

: 소스 코드 생성 프로세스를 더욱 편리하게 만듬

: 프로젝트 파일의 변경 사항을 감시하고 필요할 때마다 필요한 파일을 자동으로 빌드

: `flutter pub run build_runner watch --delete-conflicting-outputs` 를 실행하여 시작

### Generating code for nested classes

클래스 내에 중첩된 클래스가 있는 코드가 있을 경우 클래스를 서비스에 대한 인수로 JSON 형식으로 전달하려고 시도 시 Invalid 인수 오류가 발생했을 수도 있음

```dart
import 'package:json_annotation/json_annotation.dart';
part 'address.g.dart';

@JsonSerializable()
class Address {
  String street;
  String city;

  Address(this.street, this.city);

  factory Address.fromJson(Map<String, dynamic> json) =>
      _$AddressFromJson(json);
  Map<String, dynamic> toJson() => _$AddressToJson(this);
}
```

```dart
import 'package:json_annotation/json_annotation.dart';

import 'address.dart';

part 'user.g.dart';

@JsonSerializable(**explicitToJson: true**)
class User {
  User(this.name, this.address);

  String name;
  **Address address;**

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
  Map<String, dynamic> toJson() => _$UserToJson(this);
}
```

- Address 클래스는 User 클래스에 중첩
- 중첩을 수행하려면 명시적으로 `@JsonSeriaclizable()`에 `explicitToJson : True`전달

---

# Package

## Background Process

현재 활성 앱이 아닌 경우에도 백그라운드에서 Dart 코드를 실행하고 싶다면 `isolate` 설정 필요.

<aside>
❗ `isolate`
: Dart의 멀티스레딩 모델
: 메인 프로그램과 메모리를 공유하지 않는다는 점에서 기존 스레드와 다름
: 콜백 및 콜백 Dispatcher를 사용하여 백그라운드 실행을 위해 isolate 설정

</aside>

`WorkManager` 플러그인을 사용하면 앱 재시작 및 시스템 재부팅을 통해 작업을 예약하는 지속적인 백그라운드 처리 가능

## Happy paths recommendation

### 광고

인앱 광고로 모바일에서 수입 창출

google_mobild_ads 패키지를 활용한 인앱 광고

AdMob에 무료 계정을 등록해야 함

- 다양한 광고 형식 : 배너, 전체화면, native…
- 광고가 표시되는 시점 제어
- 앱에 대한 결정을 내리는데 도움이 되는 수익 창출 보고서

### 백그라운드 처리

Dart의 Headless 실행 활성화

백그라운드 처리를 사용하면 HTTP 요청 만들기, 무거운 계산, 다른 isolate에 알림 표시와 같은 작업 수행 가능

1. Dart isolate 활용 : 별도의 스레드를 만들어 백그라운드에서 동시에 작업 실행
2. WorkManager 플러그인 활용 : Dart의 영구적인 Headless 실행 활성화
    - 지속적인 작업 처리
    - 유동적인 스케줄링
    - 작업에 제약 조건 적용 (ex. 네트워크 연결 확인, 디바이스가 충전 중일때만 실행…)

<aside>
❗ 패키지와 플러그인의 차이점
플러그인은 패키지의 한 타입

</aside>

### 지리적 위치

사용자의 위치 결정

geolocater 플러그인 사용

- 권환 확인 및 요청
- 일회성 위치 가져옴
- 사용자가 이동할 때 지속적으로 업데이트되는 값 스트림 제공

### 불변 데이터

변경할 수 없는 데이터 구조 처리

1. frezzed
    - 인메모리 객체
2. json_serializable
    - 변경 불가능한 객체를 json 형식으로 매핑

독립적으로 사용될 수도 있지만 함께 사용해도 ok

### 구조화된 로컬 스토리지

데이터를 유지 및 보존

사용자 장치에 비싸거나 느린 데이터를 선택적으로 저장하여 앱 성능을 높이고 사용자 경험 개선

1. Drift
    - SQLite를 중심으로 모든 플러터 플랫폼에서 완벽하게 타입화된 객체 관계 매핑 (ORM) 제공
    - 사용자 기기에 완전한 관계형 데이터베이스가 필요한 경우
2. Hive
    - 사용자 지정 스토리지 솔루션을 중심으로 완벽하게 타입화된 객체 문서 매핑(ODM)을 모든 flutter 플랫폼에서 제공
    - 완전한 관계형 데이터베이스가 필요하지 않은 경우, 특히 서버에서 문서 기반 스토리지를 사용하는 경우(firestore)

### 웹 소켓

클라이언트 및 서버 연결 처리

플러터 클라이언트와 서버와의 의사소통을 가능하도록

1. web_socket_channel 패키지를 클라이언트 측 웹 소켓 연결에 사용
2. web_socket_connections 패키지를 서버 사이드 Dart 웹 소켓에 사용